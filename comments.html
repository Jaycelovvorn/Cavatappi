<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="comments.css">
  <style>
    body { padding: 20px; }
    .container { max-width: 900px; margin: 0 auto; }
    h1 { margin-bottom: 18px; }
    .meta-row { display:flex; gap:10px; align-items:center; margin-bottom:12px; flex-wrap:wrap }
  </style>
  <title>Comments - Cavatappi</title>
</head>
<body>
  <div class="container" id="comments-app">
    <h1>Comments</h1>

    <!-- Rating (anonymous) -->
    <div class="card" id="rating-card">
      <div class="small muted">Anonymous rating — 1 to 5 stars</div>
      <div id="rating-widget" class="stars" aria-label="Rating widget"></div>
      <div class="small muted" id="rating-summary">Loading…</div>
    </div>

    <!-- New comment form -->
    <div class="card" id="new-comment-card" style="margin-top:16px;">
      <div class="small muted">Leave a comment</div>
      <div class="meta-row">
        <input id="comment-name" placeholder="Your name (required)" required>
        <button id="download-json" title="Export comments to JSON" style="margin-left:auto">Download JSON</button>
      </div>
      <textarea id="comment-text" rows="4" placeholder="Write your comment..." required></textarea>
      <div style="margin-top:8px;">
        <button id="submit-comment">Post Comment</button>
      </div>
    </div>

    <!-- Comments list -->
    <div id="comments-list" style="margin-top:18px;"></div>
  </div>

  <script>
    // Simple client-side comments storage & UI
    // Data model: { id, parentId (null=root), name, text, dateISO }
    // Ratings model: array of numbers 1..5
    (function(){
      const STORAGE_KEY = 'cavatappi_comments';
      const RATINGS_KEY = 'cavatappi_ratings';
      const USER_VOTE_KEY = 'cavatappi_user_vote'; // stores the user's single vote (1..5)

      const commentsListEl = document.getElementById('comments-list');
      const nameInput = document.getElementById('comment-name');
      const textInput = document.getElementById('comment-text');
      const submitBtn = document.getElementById('submit-comment');
      const ratingWidget = document.getElementById('rating-widget');
      const ratingSummary = document.getElementById('rating-summary');
      const downloadBtn = document.getElementById('download-json');

      let comments = [];
      let ratings = [];
      let userVote = null;

      // utilities
      const uid = ()=> 'c' + Date.now().toString(36) + Math.random().toString(36).slice(2,8);
      const saveLocal = ()=> {
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(comments));
          localStorage.setItem(RATINGS_KEY, JSON.stringify(ratings));
          if (userVote) localStorage.setItem(USER_VOTE_KEY, String(userVote)); else localStorage.removeItem(USER_VOTE_KEY);
        } catch(e){}
      };
      const loadLocal = ()=>{
        try {
          const c = JSON.parse(localStorage.getItem(STORAGE_KEY) || 'null');
          const r = JSON.parse(localStorage.getItem(RATINGS_KEY) || 'null');
          const uv = localStorage.getItem(USER_VOTE_KEY);
          if (Array.isArray(c)) comments = c;
          if (Array.isArray(r)) ratings = r;
          if (uv) {
            const v = parseInt(uv,10);
            if (!Number.isNaN(v) && v>=1 && v<=5) userVote = v;
          }
        } catch(e){}
      };

      // Try fetch comments.json for initial data (won't work on file:// in some setups)
      fetch('comments.json').then(r=>{
        if (!r.ok) throw new Error('no json');
        return r.json();
      }).then(data=>{
        // if server data exists, use it, then merge local on top
        if (Array.isArray(data.comments)) comments = data.comments;
        if (Array.isArray(data.ratings)) ratings = data.ratings;
        loadLocal(); // overlay any local interactions
        renderAll();
      }).catch(()=> {
        // fallback to local storage
        loadLocal();
        renderAll();
      });

      // Render helpers
      function buildTree(flat) {
        const map = new Map();
        flat.forEach(c => map.set(c.id, {...c, children: []}));
        const roots = [];
        map.forEach(node=>{
          if (node.parentId) {
            const p = map.get(node.parentId);
            if (p) p.children.push(node);
            else roots.push(node);
          } else roots.push(node);
        });
        // sort by date ascending
        function sortRec(arr){ arr.sort((a,b)=> new Date(a.date) - new Date(b.date)); arr.forEach(n=>sortRec(n.children)); }
        sortRec(roots);
        return roots;
      }

      function renderAll(){
        renderRating();
        renderComments();
      }

      function renderRating(){
        ratingWidget.innerHTML = '';
        // create 5 clickable stars
        for (let i=1;i<=5;i++){
          const s = document.createElement('span');
          s.className = 'star';
          s.dataset.value = i;
          s.innerHTML = '★';
          s.title = i + ' star' + (i>1?'s':'') ;
          s.addEventListener('click', ()=>{
            // enforce one vote per user
            if (!userVote) {
              // first-time vote
              ratings.push(i);
              userVote = i;
              saveLocal();
              renderRating();
              return;
            }
            // user has voted already
            if (userVote === i) {
              alert('You already voted ' + i + ' star' + (i>1?'s':'') + '.');
              return;
            }
            // ask to change vote
            if (!confirm(`Change your vote from ${userVote} → ${i}?`)) return;
            // try remove one instance of previous vote from ratings (best-effort)
            const idx = ratings.indexOf(userVote);
            if (idx !== -1) ratings.splice(idx, 1);
            // add new vote
            ratings.push(i);
            userVote = i;
            saveLocal();
            renderRating();
          });
          ratingWidget.appendChild(s);
        }

        // add remove-vote control if user voted
        const existingRemove = document.getElementById('remove-vote-btn');
        if (existingRemove) existingRemove.remove();
        if (userVote) {
          const rem = document.createElement('button');
          rem.id = 'remove-vote-btn';
          rem.className = 'remove-vote';
          rem.textContent = 'Remove my vote';
          rem.title = 'Remove your vote so you can vote again';
          rem.addEventListener('click', ()=>{
            if (!confirm('Remove your vote?')) return;
            const idx = ratings.indexOf(userVote);
            if (idx !== -1) ratings.splice(idx,1);
            userVote = null;
            saveLocal();
            renderRating();
          });
          ratingWidget.parentNode.appendChild(rem);
        }

        // summary
        const count = ratings.length;
        const avg = count ? (ratings.reduce((a,b)=>a+b,0)/count) : 0;
        const me = userVote ? `Your vote: ${userVote} — ` : '';
        ratingSummary.textContent = count ? `${me}Average ${avg.toFixed(2)} / 5 — ${count} vote${count>1?'s':''}` : `${me}No ratings yet — be the first!`;

        // highlight average
        const rounded = Math.round(avg);
        Array.from(ratingWidget.children).forEach((el, idx)=>{
          el.classList.toggle('filled', (idx+1) <= rounded);
        });
      }

      function renderComments(){
        commentsListEl.innerHTML = '';
        const tree = buildTree(comments);
        if (!tree.length) {
          commentsListEl.innerHTML = '<div class="small muted">No comments yet.</div>';
          return;
        }
        const wrapper = document.createElement('div');
        wrapper.className = 'comment-list';
        tree.forEach(node => wrapper.appendChild(renderCommentNode(node, 0)));
        commentsListEl.appendChild(wrapper);
      }

      function renderCommentNode(node, depth){
        const el = document.createElement('div');
        el.className = 'comment';
        if (depth>0) el.classList.add('reply');
        el.innerHTML = `
          <div class="comment-head">
            <strong class="comment-name"></strong>
            <span class="comment-date small muted"></span>
          </div>
          <div class="comment-body"></div>
          <div class="comment-actions small muted">
            <button class="reply-btn">Reply</button>
          </div>
          <div class="replies"></div>
        `;
        el.querySelector('.comment-name').textContent = node.name;
        el.querySelector('.comment-date').textContent = ' • ' + (new Date(node.date)).toLocaleString();
        el.querySelector('.comment-body').textContent = node.text;

        // reply button
        const replyBtn = el.querySelector('.reply-btn');
        replyBtn.addEventListener('click', ()=>{
          openReplyForm(el.querySelector('.replies'), node.id);
        });

        // children
        const childrenContainer = el.querySelector('.replies');
        node.children.forEach(child => childrenContainer.appendChild(renderCommentNode(child, depth+1)));
        return el;
      }

      function openReplyForm(containerEl, parentId){
        // if a form already exists, ignore
        if (containerEl.querySelector('.reply-form')) return;
        const form = document.createElement('div');
        form.className = 'reply-form card';
        form.innerHTML = `
          <input class="reply-name" placeholder="Your name (required)" required>
          <textarea class="reply-text" rows="3" placeholder="Write a reply..." required></textarea>
          <div style="text-align:right; margin-top:6px;">
            <button class="reply-cancel">Cancel</button>
            <button class="reply-submit">Post Reply</button>
          </div>
        `;
        containerEl.prepend(form);

        const ta = form.querySelector('.reply-text');
        const cleanup = attachAutosize(ta);

        form.querySelector('.reply-cancel').addEventListener('click', ()=> {
          cleanup && cleanup();
          form.remove();
        });

        form.querySelector('.reply-submit').addEventListener('click', ()=>{
          const rName = form.querySelector('.reply-name').value.trim();
          const rText = form.querySelector('.reply-text').value.trim();
          if (!rName || !rText) { alert('Name and reply are required'); return; }
          const comment = { id: uid(), parentId: parentId, name: rName, text: rText, date: (new Date()).toISOString() };
          comments.push(comment);
          saveLocal();
          cleanup && cleanup();
          renderComments();
        });
      }

      // create new top-level comment
      submitBtn.addEventListener('click', ()=>{
        const n = nameInput.value.trim();
        const t = textInput.value.trim();
        if (!n || !t) { alert('Please enter your name and a comment.'); return; }
        const c = { id: uid(), parentId: null, name: n, text: t, date: (new Date()).toISOString() };
        comments.push(c);
        nameInput.value = '';
        textInput.value = '';
        // reset main textarea height
        if (mainAutosizeCleanup) mainAutosizeCleanup();
        mainTA.style.height = ''; // allow CSS min-height to apply
        // reattach autosize
        mainAutosizeCleanup = attachAutosize(mainTA);

        saveLocal();
        renderComments();
      });

      // download/export current data
      downloadBtn.addEventListener('click', ()=>{
        const payload = { comments, ratings, exportedAt: (new Date()).toISOString() };
        const blob = new Blob([JSON.stringify(payload, null, 2)], {type:'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'cavatappi-comments.json';
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      });

      // initial render (if fetch already failed)
      function initialIfNeeded(){
        renderAll();
      }
      // ensure at least one render after script loads
      setTimeout(initialIfNeeded, 50);

      // expose for debugging if needed
      window.__cavatappi_comments = { getComments: ()=>comments, getRatings: ()=>ratings, getUserVote: ()=>userVote };
    })();
  </script>
</body>
</html>
